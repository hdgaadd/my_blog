## 你先说说kafka由模块组成吧

嗯嗯知道的。

主要有：生产者、消费者、Brocker、Topic、消息分区Partition。

## 那我们先讲讲生产者、消费者？

嗯嗯好的。

## 消息生产者的异步回调，知道吧

Ok知道的。主要是可以进行**异常日志的记录**。

是这样的，kafka的**异步提交消息**相比同步提交，不需要在brocker响应前阻塞线程。

但是异步提交我们是不知道消费情况的，所以就可以在kafka消费异常时，通过其**回调**来告知程序**异常情况**。



## 消费者分区，可以介绍下吗

嗯嗯知道的。分区的作用主要就是为了提高kafka处理消息**吞吐量**。

每一个topic会被**分为多个分区**。

假如同一个topic下有n个分区、n个消费者，这样的话每个分区就会发送消息给对应的一个消费者，这样**n个消费者负载均衡**地处理消息。

同时**生产者**会发送消息给不同分区，每个分区**分给不同的brocker**处理，让集群平坦压力，这样大大提高了kafka的吞吐量。

## 那消费者手动提交和自动提交，有什么区别呢

知道的，其实就是两种不同的客户端提交方式。

1. 自动提交的话，通过设置enable.auto.commit为true，**每过5秒**消费者客户端就会自动提交最大偏移量
2. 手动提交的话，通过设置enable.auto.commit为false，让消费者客户端消费**程序执行后**提交当前的偏移量

![微信截图_20240315174910](D:\code\z-mine\my_blog\2024.3.15\微信截图_20240315174910.png)

## 都有什么优缺点呢

1. 自动提交的话，比较方便**只需要配置**就可以，不过可能会导致消息丢失或重复消费
   - 如果刚好到了5秒时**提交了**最大偏移量，此时正在消费中的消费者客户端崩溃了，就会导致**消息丢失**
   - 如果成功消费了，下一秒应该自动提交，但此时消费者客户端奔溃了**提交不了**，就会导致其他分区的消费者**重复消费**
2. 手动提交的话，需要**写程序**手动提交，要分两种提交方式
   - 手动提交是**同步提交**的话，在broker对请求做出回应之前，客户端会一直阻塞，这样的话限制应用程序的**吞吐量**
   - 是**异步提交**的话，不会有吞吐量的问题。不过发送给broker偏移量之后，**不会管**broker有没有收到消息

![微信截图_20240315173659](D:\code\z-mine\my_blog\2024.3.15\微信截图_20240315173659.png)