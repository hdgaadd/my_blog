## 知道ZooKeeper有什么应用场景吗

嗯嗯，主要有这几种。

1. 数据发布/订阅

   可以用来实现配置中心

2. 分布式锁

3. 命名服务

   类似于UUID，可以生成全局唯一的ID

4. 集群管理

   每一个服务器是一个子节点，可以用来检测到集群中机器的上/下线情况

## 你挑一个你比较熟悉的场景讲讲
嗯嗯好的，那我讲下分布式锁。

是这样的，ZooKeep的获取锁是在**/exclusive_lock节点**下创建子节点，如果创建成功则获得锁。如果**失败**，则客户端会在该节点注册一个**子节点变更的Watcher监听**。

同样，释放锁则**删除**该子节点，此时Watcher监听就是通知客户端可以重新获取了。

![微信截图_20240307164855](D:\code\z-mine\my_blog\2024.3.7\微信截图_20240307164855.png)

## 你说的是排他锁，共享锁呢
好的面试官。共享锁也是类似的场景。

每次**读、写**请求同样是创建子节点，是一个类似于“/shared_lock/[Hostname]-请求类型-序号”的临时**顺序**节点。

**接着获取子节点和注册Watcher监听**。

1. 获取读锁的话，如果前面比自己小的序号**没有写请求**，则可以读
2. 获取写锁的话，只有在自己是**序号最小**的情况下，才可以读

而共享锁的释放锁和排他锁都是一样的。

![微信截图_20240307174002](D:\code\z-mine\my_blog\2024.3.7\微信截图_20240307174002.png)

## emmmm有没听说过共享锁的羊群效应
噢噢知道的面试官，这个问题主要是出现在**集群规模比较大**的业务场景下。

其实共享锁的特别之处，就在每次**读、写**请求都要**注册Watcher监听来获取子节点列表****，特别是数量更多的读请求。

子节点列表每次变动都要通知**所有**的服务器客户端，造成了短时间大量的**事件通知**，给ZooKeeper带来巨大性能消耗。



## 怎么解决呢

我认为要两方面来看吧。

首先我上面说的共享锁实现方式如果在集群不大的情况下是可行的，且他实现**简单实用**。而如果在集群规模大的场景下，可以这样**改进**。

读、写请求首先获取子节点列表，但都**不注册Watcher监听**。

- 读请求：只向比自己序号小的最后一个写请求节点注册Watcher监听
- 写请求：只向比自己序号小的最后一个节点注册Watcher监听

这样就可以避免羊群效应，主要是**从监听子节点列表，改进为只监听某个子节点**。

## Kafka应用场景呢，能说说Kafka怎么利用ZooKeeper的吗

