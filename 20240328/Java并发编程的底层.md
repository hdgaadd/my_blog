## synchronized的实现原理

synchronized的实现是基于monitor的。

是这样，任何对象都有一个**monitor**与之关联，当monitor被持有后，对象就会处于**锁定状态**。

而在同步代码块的**开始位置**，在编译期间会被插入**monitorenter指令**。

当线程执行到monitorenter指令时，就会尝试获取**monitor**的所有权，获取得到则获得锁资源。

## 那synchronized有什么缺点吗

synchronized是属于**重量级锁**。

1. synchronized需要频繁的**获得锁、释放锁**，这带来了不少性能消耗。

2. 另外没有获得锁的线程会被操作系统进行阻塞、唤醒。

   而**唤醒操作**需要保存当前线程状态，切换到下一个线程，也就是进行**上下文切换**。

   上下文切换是很耗费资源的一种操作。

## JDK做了什么功夫来解决这些缺点呢

引入了偏向锁、轻量级锁、重量级锁，也就是锁升级。

多线程环境其实有各种不同的场景，这三种锁就是为了**适应各种不同场景**，来使并发的效率最高。

1. 只有**一个线程**访问同步代码块的场景的话，会进入偏向锁状态。

   偏向锁会**偏向访问它的线程**，使其加锁、解锁不需要额外的消耗。

2. 有**少量线程竞争**的场景的话，偏向锁会**升级为轻量级锁**。

   而轻量级使用**CAS操作**来获得锁，CAS操作**不需要获得锁、释放锁**，减少了像synchronized带来的**上下文切换**资源消耗



## 那轻量级锁没有缺点吗

有的，没有获得锁的线程会**自旋**，这需要消耗CPU的。

另外如果**自旋10次失败**的话，为了**减少CPU的消耗**，轻量级锁会升级为**重量级锁**，也就是回到了类似synchronized重量级锁的同步场景。



